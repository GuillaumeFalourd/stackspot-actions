import requests
import time
import json
import os

# Step 1: Authentication to obtain access token
def get_access_token(account_slug, client_id, client_key):
    url = f"https://idm.stackspot.com/{account_slug}/oidc/oauth/token"
    headers = {'Content-Type': 'application/x-www-form-urlencoded'}
    data = {
        'client_id': client_id,
        'grant_type': 'client_credentials',
        'client_secret': client_key
    }
    response = requests.post(url, headers=headers, data=data)
    response_data = response.json()
    return response_data['access_token']

# Step 2: Creation of a Quick Command (RQC) execution
def create_rqc_execution(qc_slug, access_token, input_data):
    url = f"https://genai-code-buddy-api.stackspot.com/v1/quick-commands/create-execution/{qc_slug}"
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}'
    }
    data = {
        'input_data': input_data
    }

    # print('File data to analyze:', data) 
    response = requests.post(
        url,
        headers=headers,
        json=data
    )

    if response.status_code == 200:
        decoded_content = response.content.decode('utf-8')  # Decode bytes to string
        extracted_value = decoded_content.strip('"')  # Strip the surrounding quotes
        response_data = extracted_value
        print('ExecutionID:', response_data)
        return response_data
    else:
        print(response.status_code)
        print(response.content)

# Step 3: Polling for the execution status
def get_execution_status(execution_id, access_token):
    url = f"https://genai-code-buddy-api.stackspot.com/v1/quick-commands/callback/{execution_id}"
    headers = {'Authorization': f'Bearer {access_token}'}
    i = 0
    while True:
        response = requests.get(
            url, 
            headers=headers
        )
        response_data = response.json()
        status = response_data['progress']['status']
        if status in ['COMPLETED', 'FAILURE']:
            return response_data
        else:
            print("Status:", f'{status} ({i})')
            print("Execution in progress, waiting...")
            i+=1
            time.sleep(5)  # Wait for 5 seconds before polling again

def run(metadata):
    # Replace the placeholders with your actual data
    inputs = metadata.inputs
    CLIENT_ID = inputs.get("stk_client_id")
    CLIENT_KEY = inputs.get("stk_client_key")
    ACCOUNT_SLUG = 'stackspot'
    QC_SLUG = 'sast-rqc-v0'

    current_directory = os.getcwd()  # Get the current working directory
    all_vulnerabilities = 0
    for root, dirs, files in os.walk(current_directory):
        files_amount = len(files)
        print(f'\n\033[36m {files_amount} files detected in the directory {current_directory}\033[0m')
        for file in files:
            file_path = os.path.join(root, file)
            # List of file extensions to exclude
            excluded_extensions = ('.md', '.txt', '.yaml', '.yml', '.stkignore', '.rego', '.editorconfig', '.xml', '.DS_Store', '.json', '.cmd')

            # List of substrings to exclude
            excluded_substrings = [".git", ".idea", ".mvn", ".stk", "postman", "pgadmin", "target"]

            # Check if the file path should be excluded
            if not file_path.endswith(excluded_extensions) and not any(substring in file_path for substring in excluded_substrings):
                print(f'\n\033[36mFile Path: {file_path}\033[0m')
                # Open the file and read its content
                with open(file_path, 'r') as file:
                    file_content = file.read()

                vulnerabilities_amount = None  # Initialize the variable

                try:
                    # Execute the steps
                    access_token = get_access_token(ACCOUNT_SLUG, CLIENT_ID, CLIENT_KEY)
                    execution_id = create_rqc_execution(QC_SLUG, access_token, file_content)
                    execution_status = get_execution_status(execution_id, access_token)

                    print('Execution status:', execution_status)

                    result = execution_status['result']

                    # Remove the leading and trailing ```json and ``` for correct JSON parsing
                    if result.startswith("```json"):
                        result = result[7:-4].strip()

                    result_data = json.loads(result)

                    vulnerabilities_amount = len(result_data)
                except KeyError as e:
                    print(f"KeyError: {e} - Verifique se a chave 'steps', 'step_result' ou 'answer' está presente na resposta.")
                except IndexError as e:
                    print(f"IndexError: {e} - Verifique se a lista 'steps' contém elementos suficientes.")
                except json.JSONDecodeError as e:
                    print(f"JSONDecodeError: {e} - Verifique se a string JSON está formatada corretamente.")
                except Exception as e:
                    print(f"Erro inesperado: {e}")

                if vulnerabilities_amount is not None and vulnerabilities_amount > 0:
                    all_vulnerabilities += vulnerabilities_amount
                    print(f"\n\033[36m{vulnerabilities_amount} item(s) have been found for file {file_path}:\033[0m")

                    # Iterate through each item and print the required fields
                    for item in result_data:
                        print(f"\nTitle: {item['title']}")
                        print(f"Severity: {item['severity']}")
                        print(f"Correction: {item['correction']}")
                else:
                    print(f"\n\033[36m {file_path}: is clean!\033[0m")
            else:
                print(f"\n{file_path} bypassed!")
    if all_vulnerabilities > 0:
        print(f"\n\033[36m{all_vulnerabilities} vulnerabilities have been found in project! Please, check the previous reports.\033[0m")

                    
